摘自：https://mp.weixin.qq.com/s/mJ_jZZoak7uhItNgnfmZvQ
```java
//用递归的方法反转链表
 public static Node reverseList2(Node head){
     // 1.递归结束条件
     if (head == null || head.next == null) {
              return head;
          }
          // 递归反转 子链表
          Node newList = reverseList2(head.next);
          // 改变 1，2节点的指向。
         // 通过 head.next获取节点2
         Node t1  = head.next;
         // 让 2 的 next 指向 2
         t1.next = head;
         // 1 的 next 指向 null.
        head.next = null;
        // 把调整之后的链表返回。
        return newList;
    }
```
注解：我对 newList 的理解
reverseList2 函数每次返回的都是什么呢？最后 的newList 代表什么呢？ 中间递归时不怕链表断开？
```javascript
// 经过一番思考 我的担心是多余的 哈哈哈
第一传入函数的是 head 指针 1 -> 2 -> 3 -> 4
第二次： 2 -> 3 -> 4
第三次： 3 -> 4
第四次： 4 此时 4.next 是null  立即返回'head' 此时的head 是 4 的地址 

第三次执行函数结果： 4 -> 3 此时 2 -> 3 也就是 4 和 2的next 同时指向 3 的地址 [head.next 保留了 2 对 3 的指向 2 和 3 之间没有断开]
执行顺序：[先]4 -> 3  之后   [后]2 -> 3  变成了 3 -> 2  因为 如果先是 3 -> 2 的话 4 就丢了 没人指向它  就永远找不到了

还有一个点是 每次递归 head 的 next 都指向 null 为什么最后还串起来了？
比如：3 -> 4 变为 4 -> 3 head原本指向3 head.next 指向4  让head.next.next 指向3 这样的话 就是 4 -> 3 成功！此时head仍然指向 3 head.next = null 之后 2 -> 3 怎么变为 3 -> 2? 3 -> null 呀？
这我自己就很搞笑了 被自己笑晕 哈哈哈哈哈 请问自己：3 -> 4 4 是不是指向了null?? 他们换成功了啊！ 而且 3 -> null 没关系的 我们只要保证 此时 2 -> 3 之间没断开呢就行了～
这更加证明了 [先]4 -> 3  之后   [后]2 -> 3  变成了 3 -> 2 因为 [先] 3 -> null [后]之后 3 -> 2 连起来了

还有一点：最后的最后 函数每次都会返回 newList 请问最后返回的是谁？指向哪里？ 怎么返回的 最后返回的是这个值？
if (head == null || head.next == null) {
     return head; 👈注意这里 // 传入 4 时 4.next 指向 null 立即返回 head 也就是 4 的地址 head -> 4 递归结束条件
}
 Node newList = reverseList2(head.next); 
 注意这里👆
 newList 到底是谁 每次执行都要 赋值再返回 仔细想一下 或者画一下图 很好理解 newList 就是 递归结束条件处 return 的值 4 的地址 最后的head
 我们的思维是 
 1->2->3->4
 2->3->4
 3->4
 4->null
 这样的传入函数的过程 但是如果一切真的按照 从上往下的顺序执行 显然不对 上面已经证明了 我们是按照 从下往上的顺序 去反转链表 
 还有如果 从上到下 newList 第一次被赋值为什么呢？你是不是还要去想 又去调函数了 函数又调函数了 返回值 是谁呢 ？再想一下 就有答案了 就是 从下往上执行的 4->null 的情况
 即 newList 最初被赋值为 4 的地址 然后一路被 二次 三次 四次...return 回来
 当然 为什么return回来   不return 回来 4 的地址;  直接return;  也是可以结束 递归的  
 但是 链表反转之后 你总得去访问吧 有头节点吧 4->3->2->1->null
 4 的地址就是头节点  
 并且我们一层一层 把最底端的这个头节点 返回来了 这种可以考虑优化的～【占用栈空间 栈 是有限的】【尾递归优化】【尾调用】
 考虑两种优化方式：
 1. 不要进行不必要的计算 递归问题是有很多子问题的 那斐波那契数列来说 f(n)=fn(n-1)+f(n-2) 【fn(n-1)+f(n-2)是f(n)最优子结构 f(1) f(2) 是边界 】 后两位就是子问题 可能f(5) 被计算好几次 因为 f(6) = f(5) + f(4)   f(7) = f(6) + f(5) 就重复了 我们可以采用 数组或者 哈是hashmap 去保存已经 计算过的子问题 存在直接取 不用再计算 这种方式存储 n--> f(n)
 2. 递归 函数会进栈 占用内存 优化方式：尾递归调用 递推【我认为就是迭代～～】
 💐
 好了 完美诠释 结束🔚


```
