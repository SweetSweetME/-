最近两天在看算法：
关于🌲的那些事儿
答题时 主要又两种思路：递归和迭代
一般递归的思路更容易想出来 也更容易理解
  比如我是这样想的：
    递归 函数调用自身 那么只要想好了根结点以及它的左右子节点如何处理就可以了 两次以left right 两个子节点 去调用函数本身 也就是走它父母走过的路 
    当然这里的 即使父亲也是👩 判断 left 和 right 都为null  才是结束的标志✅ 不能缺少 不然会造成 堆栈溢出 
    
    堆栈溢出 是递归很容易造成的一个 因为 函数返回一个函数【还是自己】  原本那个函数还没执行完毕 因为 return 里可能还等着这个 函数执行完再去做别的操作 比如加减乘除
    那么就会保留这个函数的栈内存 递归没有尽头 那么 就会一直开辟内存 最终造成 堆栈溢出
    
    
面试官这样和我说过：
  能用递归实现的 迭代肯定以及一定！也能实现  👏 我挂过 是的！
  迭代的话 会涉及到 和 栈 或者 队列 配合使用 一个 while 循环 ♻️ 判断栈或者 队列 是否为空 不为空则进入循环 取出一个值 进行一系列操作 为空则 走最后的return
  也有可能 栈 或者 队列 不为空时  就return 比如：判断两棵树是不是 一样的 或者镜像的 只要出现了 不相等情况 就会提前return
  
  这里还要备注一下 好久没用到的：continue 不执行后面的代码 直接进入下一层循环
  javascript 没有 栈 和 队列 这种数据结构 但是可以利用数组模拟 毕竟数组的方法还是很多的 push:尾部➕ pop: 尾部➖ shift:头部➕ unshift:头部➖
  
